# _*_ coding:utf-8 _*_
__author__ = 'brian'
__date__ = '2019/3/14 0014 22:58'

"""
re模块  ---- python里使用正则表达式的方法

匹配模式：默认为贪婪模式    ---- 匹配尽可能长的字符串

元字符：
    .   ---- 匹配除了换行符以外的所有单个字符
    \w  ---- 匹配所有的字母数字和下划线
    \s  ---- 匹配所有的空位符，包括空格回车制表符等
    \d  ---- 匹配所有的数字
    PS  如果是大写的\W \S \D，则表示匹配所有的非\w \s \d内容

    ^   ---- 表示匹配整个字符串以^后字符串开头的内容
    $   ---- 表示匹配以$前字符结尾的字符串内容

    \n  ---- 换行符
    \t  ---- 制表符 tab
    \b  ---- 匹配单词的结尾

    a|b ---- 匹配满足a或者b的全部内容
    ()  ---- 匹配括号内的内容，或者表示分组；可以用group接受各个分组
    []  ---- 字符组
    [^...]  ---- 匹配字符组中非...的内容

量词：仅能约束量词前面的那一个元字符
        ---- 如要约束多个,可以使用()把要约束的多个括起来;分组中可以使用?P<...>对分组进行命名.方便后续的group('...')调用
    *   ---- 表示出现0次或多次
    +   ---- 表示出现1次或多次
    ?   ---- 表示出现0次或1次
    {n} ---- 表示重复n次
    {n,}    ---- 表示重复n次或更多，包含n
    {n,m}   ---- 表示重复n至m次,包含n和m

转义符：
    r'...'  ---- 正则表达式用r表示转义

常用的非贪婪匹配（惰性匹配）Pattern：
    *?  ---- 重复任意次，但尽量少匹配
    +?
    ??  ---- 重复0次或1次，但尽量少匹配
    {n,}
    {n,m}

.*?的常规用法：
    ---- 取尽量少的.字符
    ---- .*?x ,取前面任意长度字符，知道匹配到x字符

匹配方法：
findall(pattern, str, flag)  # 找出str所有的，符合pattern表达式的内容，所有符合匹配要求的字符串返回一个列表
    PS: flag标志位，有以下选项，也可不填   
            re.I: 忽略大小写
            re.M: 多行模式，改变^和$的判定,以每一行的开始和结束作为开始和结束，而不是字符串整体的开始结束
            re.S: 使得.号可以匹配换行符
finditer(pattern, str, flag)  # 使用方法同findall,返回的是迭代器,其中的每个元素都要调用其group()方法
search(pattern, str, flag)  # 找到str中,第一个符合pattern表达式的字符串,可以调用返回值的group()方法,访问匹配到的字符串
match(pattern, str, flag)  # 用法及返回值同search,只是它需要从头开始就要满足正则表达式.中间开始的不会进行匹配
split(pattern, str, flag)  # 按pattern对str进行分割,返回列表
sub(pattern, s_replace, str, num)  # 对str中符合pattern的字符串用s_replace进行替换,替换num个,num默认全部,返回替换完成的str
sub(pattern, s_replace, str, num)  # 用法同sub(),返回值为替换完成的str和num组成的2-tuple
compile(pattern)  # 编译pattern,方便后续多次调用这条匹配规则. 使用类似 pattern.findall()方法进行多次调用

"""

import re

a = """afbcff defbafdsfb"""
ret = re.search('(?P<fb>fb)+|(?P<af>af)+', a)
print(ret.group('af'))